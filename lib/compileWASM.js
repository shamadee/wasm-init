// compileWASM.js
const fs = require('fs');
const path = require('path');
const exec = require('child_process').exec;
const colors = require('colors');
const os = require('os'),cpuCount = os.cpus().length;

/**
 * This function pulls parameters from the wasm.config.js file,
 * sets the emcc environment and calls the emcc compile arguments
 * via shell commands
 * @param {Object} config
 */
function compileWASM (config) {

  // check that emscripten path is correct
  if (!fs.existsSync(config.emscripten_path)) {
    return process.stdout.write(colors.red(`Error: Could not find emscripten directory at ${config.emscripten_path}\n`));
  }

  const shellScript = getShellScript(config);
  
  // format exported functions, if present, from config for shell script
  let expFuncStr = '';
  if (config.exported_functions && config.exported_functions.length > 0) {
    let expFuncs = config.exported_functions.reduce((acc, val) => acc.concat('\'', val, '\'\,'), '[');
    expFuncs = expFuncs.substring(0, expFuncs.length - 1).concat(']');
    expFuncStr = `-s EXPORTED_FUNCTIONS="${expFuncs}" `;
  }

  // format flags from config for shell script
  const flags = config.flags.reduce((acc, val) => acc.concat(' ', val), '');
  // construct the default compile mode string.
  let commandStr = `emcc -o ${config.outputfile} ${config.inputfile} ${expFuncStr} ${flags}`;
  // generate a command string suitable for cmake
  if(config.mode == "build") {
    // assuming make
    config.generator = config.generator ? config.generator : 'make';
    switch(config.generator) {
      case 'ninja':
        config.gen_flag = 'Ninja';
      default:
        config.gen_flag = '"Unix Makefiles"';
        break;
    }
    // need to triple escape double quotes
    expFuncStr = expFuncStr.replace(/"/g, '\\\"');
    let modFlags = flags.replace(/"/g, '\\\"');
    let cxxFlagStr = `SET(WASM_CXXFLAGS "${modFlags} ${expFuncStr}" CACHE PATH "")`;
    // pass through cmake configuration, inc. compiler flags, exported functions
    commandStr = `cd wasm && emcmake cmake -G ${config.gen_flag} `+
      `-DWASM_CXXFLAGS=\"${modFlags} ${expFuncStr}\" ` +
      `.. && emmake ${config.generator} -j${cpuCount-1}`;
  }
  process.stdout.write(colors.cyan('Running emscripten...\n'));
  // execute shell script
  // exec(shellScript, (error, stdout, stderr) => {

  exec(`
  if [[ :$PATH: != *:"/emsdk":* ]]
  then
    # use path to emsdk folder, relative to project directory
    BASEDIR="${config.emscripten_path}"
    EMSDK_ENV=$(find "$BASEDIR" -type f -name "emsdk_env.sh")
    source "$EMSDK_ENV"
  fi

  ${commandStr}
  `, { shell: '/bin/bash' }, (error, stdout, stderr) => {
    // check for emcc compile errors
    if (stderr) {
      process.stderr.write(colors.red.bold('EMSCRIPTEN COMPILE ERROR\n'));
      process.stderr.write(colors.white(stderr));
    } else {
      process.stdout.write(stdout);
      insertEventListener(config);
      process.stdout.write(colors.green.bold('Compiled C++ to WASM\n'));
    }
  });
}

/**
 * Inserts an event listener into the autogenerated lib.js file
 * to notify us when WebAssembly has finished loading. As of April 2017,
 * this is needed because Firefox doesn't reliably emmit a script onload
 * notification
 * @param {Object} config
 */
function insertEventListener (config) {
  let outFile = path.join(process.cwd(), config.outputfile);
  let tempFile = `${outFile.slice(0, outFile.lastIndexOf('.'), 0)}.temp${outFile.slice(outFile.lastIndexOf('.'))}`;
  // read in generated emscripten file
  fs.readFile(outFile, 'utf-8', (err1, data) => {
    if (err1) process.stderr.write(colors.white(err1));
    // insert eventListener
    data = data.replace(/else\{doRun\(\)\}/g, 'else{doRun()}script.dispatchEvent(doneEvent);');
    // write data to temporary file
    fs.writeFile(tempFile, data, (err2) => {
      if (err2) process.stderr.write(colors.white(err2));
      // rename temporary file to original file name
      fs.renameSync(tempFile, outFile);
    });
  });
}

function getShellScript(config) {
  const compileCommand = getCompileCommand(config);

  if (isWin()) {
    return compileCommand;
  } else {
    return `
      if [[ :$PATH: != *:"/emsdk":* ]]
      then
        # use path to emsdk folder, relative to project directory
        BASEDIR="${config.emscripten_path}"
        EMSDK_ENV=$(find "$BASEDIR" -type f -name "emsdk_env.sh")
        source "$EMSDK_ENV"
      fi

      ${compileCommand}
      `;
  }
}

function getCompileCommand(config) {
  // format exported functions, if present, from config for shell script
  let expFuncStr = '';
  if (config.exported_functions && config.exported_functions.length > 0) {
    let expFuncs = config.exported_functions.reduce((acc, val) => acc.concat('\'', val, '\'\,'), '[');
    expFuncs = expFuncs.substring(0, expFuncs.length - 1).concat(']');
    expFuncStr = `-s EXPORTED_FUNCTIONS="${expFuncs}" `;
  }

  // format flags from config for shell script
  const flags = config.flags.reduce((acc, val) => acc.concat(' ', val), '');

  return `emcc -o ${config.outputfile} ${config.inputfile} ${expFuncStr} ${flags}`;
}

function isWin() {
  return /^win/.test(process.platform);
}

module.exports = {
  compileWASM,
  insertEventListener,
};
